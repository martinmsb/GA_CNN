import torch
import torch.nn as nn
import torch.optim as optim
import sys

class CNN(nn.Module):
    
    # Hyperparameters
    batch_size = 64
    # Modify this parameter if dataset is changed
    num_classes = 10
    learning_rate = 0.001
    num_epochs = 20

    # GPU selection if available. If not CPU is selected
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

    def __init__(self, config, c_skernels, c_nchannels, p_skernels):
        super().__init__()
        """
        Construct a new CNN object
        :param config: array containing the configuration of each layer
        :param c_skernel: array containing the kernel size of each convolutional layer
        :param c_nchannels: array containing the number of channels generated by each convolutional
        :param p_skernel: array containing the kernel size of each pooling layer
        :return: -
        """
        actual_inchannels = 1
        conv_count = 0
        p_count = 0
        self.layers=nn.ModuleList()
        for layer in config:
            if(layer == 'c'):
                # Convolutional Layer
                self.layers.append(nn.Conv2d(in_channels=actual_inchannels, out_channels=c_nchannels[conv_count], kernel_size=c_skernels[conv_count]))
                actual_inchannels = c_nchannels[conv_count]
                conv_count+=1
            
            if(layer == 'mp'):
                self.layers.append(nn.MaxPool2d(kernel_size =p_skernels[p_count], stride = 2))
                p_count+=1

            if(layer == 'ap'):
                self.layers.append(nn.AvgPool2d(kernel_size =p_skernels[p_count], stride = 2))
                p_count+=1
        self.layers.to(self.device)
        self.relu = nn.ReLU()
        self.flatten = nn.Flatten()
        self.linear = nn.LazyLinear(10)

    def forward(self, x):
        """
        Defines how the input will be processed
        :param x: input
        :return: input transformed by the CNN
        """
        try:
            out = x
            counter = 0
            for layer in self.layers:
                counter+=1
                if(isinstance(layer, nn.MaxPool2d) or isinstance(layer, nn.AvgPool2d)):
                    out = layer(out)
                else:
                    out = self.relu(layer(out))
            out = self.flatten(out)
            out = self.linear(out)
            return out
        except Exception as e:
            print("ERROR")
            print("Exception throwed during forward processing because the network architecture in trying to reduce the image below 1x1.")
            print("Recomendation: Reduce the maximum number of layers or use bigger images.")
            print("Exception message: "+str(e))
            sys.exit(1)

def model_train(model: CNN, train_loader):
    """
    Training of a CNN using a train loader
    :param model: CNN that is going to be trained
    :param train_loader: Data Loader containing the train data
    :return: -
    """
    model.train()
    model.to(model.device)
    # Set optimizer 
    L2_lambda = 1.0
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=model.learning_rate, weight_decay=L2_lambda)
    
    # We use the pre-defined number of epochs to determine how many iterations to train the network on
    for epoch in range(model.num_epochs):
        #Load in the data in batches using the train_loader object
        for _, (images, labels) in enumerate(train_loader): 
            # Move tensors to the configured device
            images = images.to(model.device)
            labels = labels.to(model.device)
            
            # Forward pass
            outputs = model(images)
            loss = criterion(outputs, labels)
            
            # Backward and optimize
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

def model_test(model: CNN, test_loader):
    """
    Testing of a model using a test loader
    :param model: CNN that is going to be tested
    :param test_loader: Data Loader containing the test data
    :return: Accuracy of the network in percentage
    """
    model.eval()
    with torch.no_grad():
        correct = 0
        total = 0
        for images, labels in test_loader:
            images = images.to(model.device)
            labels = labels.to(model.device)
            outputs = model(images)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
        
        #print('Accuracy of the network on the test images: {} %'.format(100 * correct / total))
    return (100 * correct / total)